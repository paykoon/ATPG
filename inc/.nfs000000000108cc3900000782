#ifndef _BITOPERATION_H
#define _BITOPERATION_H

#include <vector>
using namespace std;

namespace BitOperation {
	class bitvector {
    private:
    	unsigned int bsize;
    	unsigned int wsize;
    	unsigned int counter;
    	vector<uint64_t> data;
    	static const int WSIZE = 64;

  	public:
  		bitvector(int size) {
        last_w = 0;
        last_b = 0;
  			set_size(size);
  		}

  		bitvector() {
  			bsize = 0;
  			wsize = 0;
  			counter = 0;
  		}

  		~bitvector(){}

  		void copy(bitvector &cpy) {
  			bsize = cpy.size();
  			wsize = cpy.word_size();
  			counter = cpy.count();
  			data.resize(wsize);
  			for (int i = 0; i < wsize; i++)
  				data[i] = cpy.get_word(i);
  		}

  		void clear() {
  			counter = 0;
  			for (int i = 0; i < wsize; i++)
  				data[i] = 0ULL;
  		}

  		void setall() {
  			counter = bsize;
  			int i = 0;
  			while (i < wsize - 1)
  				data[i++] = 0xFFFFFFFFFFFFFFFFULL;
  			int p = bsize%WSIZE;
  			if (!p) {
  				data[i] = 0xFFFFFFFFFFFFFFFFULL;
  			}
  			else {
  				uint64_t d = 0ULL;
  				while (p > 0) {
  					d = d << 1;
  					d |= 1ULL;
  					p--;
  				}
  				data[i] = d;
  			}
  		}

  		void set_size(int size) {
  			bsize = size;
  			wsize = bsize / WSIZE; if (bsize%WSIZE != 0) wsize++;
  			counter = 0;
  			data.resize(wsize);
  			for (int i = 0; i < wsize; i++)
  				data[i] = 0ULL;
  		}

  		int size() {
        return bsize;
      }

  		unsigned int count() {
        return counter;
      }

  		void set(int pos) {
  			int p1 = pos / WSIZE;
        int p2 = pos % WSIZE;
  			uint64_t mask = 1ULL << p2;
  			uint64_t bval = data[p1] & mask;
  			if (!bval) {  //If this position is ready "1", then don't need to do anything
  				data[p1] |= mask;
  				counter++;
  			}
  		}

  		void reset(int pos) {
  			int p1 = pos / WSIZE; int p2 = pos%WSIZE;
  			uint64_t mask = 1ULL << p2;
  			uint64_t bval = data[p1] & mask;
  			if (bval) {
  				data[p1] &= (~mask);
  				counter--;
  			}
  		}

  		bool is_allset() {
  			return (count() == bsize);
  		}

      // mode = 0, search from start.
      // mode = 1, search from last position.
      // return the position of 1.
      // return -1, cannot find anymore 1.
      int last_w;
      int last_b;
  		int one_iterator(int mode) {
        if (mode == 0) {
          last_w = 0;
          last_b = 0;
        }
        int w = last_w;
        int b = last_b;
        while (w < wsize) {
          while (w < wsize && data[w] == 0) {
            w++;
            b = 0;
          }
          int val = data[w];

          w++;
        }
  			return -1;
  		}

  		int word_size() {
        return wsize;
      }

  		uint64_t get_word(int loc) {
        return data[loc];
      }

  		int or_count(bitvector& b) {
  			for (int i = 0; i < wsize; i++)
  				data[i] |= b.get_word(i);

  			return recount();
  		}

  		int and_count(bitvector& b) {
  			//if (b.size() != bsize)
  			//  return 0;
  			for (int i = 0; i < wsize; i++)
  				data[i] &= b.get_word(i);

  			return recount();
  		}

  		int mask_count(bitvector& b) {
  			//if (b.size() != bsize)
  			//  return 0;
  			for (int i = 0; i < wsize; i++)
  				data[i] &= (~b.get_word(i));

  			return recount();
  		}

  		int not_count() {
  			for (int i = 0; i < wsize; i++)
  				data[i] = ~data[i];

  			counter = bsize - counter;
  			return counter;
  		}

      const uint64_t m1 = 0x5555555555555555;
    	const uint64_t m2 = 0x3333333333333333;
    	const uint64_t m4 = 0x0f0f0f0f0f0f0f0f;
    	const uint64_t m8 = 0x00ff00ff00ff00ff;
    	const uint64_t m16 = 0x0000ffff0000ffff;
    	const uint64_t m32 = 0x00000000ffffffff;
    	const uint64_t hff = 0xffffffffffffffff;
    	const uint64_t h01 = 0x0101010101010101;

    	int count64(uint64_t x) {
    		x -= (x >> 1) & m1;
    		x = (x & m2) + ((x >> 2) & m2);
    		x = (x + (x >> 4)) & m4;
    		return (x * h01) >> 56;
    	}

    	int count_or(bitvector& b1, bitvector& b2) {
    		if (b1.size() != b2.size())
    			return 0;
    		int counter = 0;
    		for (int i = 0; i < b1.word_size(); i++)
    			counter += count64((b1.get_word(i) | b2.get_word(i)));

    		return counter;
    	}

    	int count_and(bitvector& b1, bitvector& b2) {
    		if (b1.size() != b2.size())
    			return 0;
    		int counter = 0;
    		for (int i = 0; i < b1.word_size(); i++)
    			counter += count64((b1.get_word(i) & b2.get_word(i)));

    		return counter;
    	}

    	int count_or(bitvector& b1, bitvector& b2, bitvector& mask) {
    		if (b1.size() != b2.size() || b2.size() != mask.size())
    			return 0;
    		int counter = 0;
    		for (int i = 0; i < b1.word_size(); i++)
    			counter += count64((b1.get_word(i) | b2.get_word(i)) & ~mask.get_word(i));

    		return counter;
    	}

    	int count_and(bitvector& b1, bitvector& b2, bitvector& mask) {
    		if (b1.size() != b2.size() || b2.size() != mask.size())
    			return 0;
    		int counter = 0;
    		for (int i = 0; i < b1.word_size(); i++)
    			counter += count64((b1.get_word(i) & b2.get_word(i)) & ~mask.get_word(i));

    		return counter;
    	}
	};

}

#endif
