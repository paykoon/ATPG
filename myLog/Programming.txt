------2017.11.30-------
Read the main.cc of glucose, need to understand the function in Dimacs.h
readClause(in, S, lits); //********
S.addClause_(lits); }    //********

------2017.12.15-------

need to know the way to use the library of glucose

----2017.12.17-----
template<class B, class Solver>
static void readClause(B& in, Solver& S, vec<Lit>& lits) {
    int     parsed_lit, var;
    lits.clear();
    for (;;){
        parsed_lit = parseInt(in);
        if (parsed_lit == 0) break;
        var = abs(parsed_lit)-1;
		//***********
    //print var's value , make sure the understanding..
        while (var >= S.nVars()) S.newVar();
        lits.push( (parsed_lit > 0) ? mkLit(var) : ~mkLit(var) );
    }
}

//----2017.12.18-------
the way to input the CNF formula
in readClause function
static void readClause(B& in, Solver& S, vec<Lit>& lits) {
    int     parsed_lit, var;
    lits.clear();
    for (;;){
		//*****usage: send all literal to parsed_lit one by one, send "0" at last******
        parsed_lit = parseInt(in);
        if (parsed_lit == 0) break; // the end of line has "0". when meet it, break.
        var = abs(parsed_lit)-1;
		//*****
        while (var >= S.nVars()) S.newVar();
        lits.push( (parsed_lit > 0) ? mkLit(var) : ~mkLit(var) );
    }
}

in main functions. we can write the answer
//********************************************
if (ret == l_True){
  printf("***************SAT Solutin**************\n");
  for (int i = 0; i < S.nVars(); i++) {
    if (S.model[i] != l_Undef) {
      int out = (S.model[i]==l_True)? 1 : 0;
      printf("%d ",out);
    }
  }
  printf("\n");
}
else if (ret == l_False){
    printf("***************UNSAT***************\n");
}
//********************************************



*****TODO******still undone
//2018.1.27
TO DO:
verify the result of glucose in S27
link to circuit by XOR, and put it into SAT-solver
write the program for SIS

// 2018.1.30
TO DO:
link the output with XOR(circuit.h --> function oriXORFaulty)

// 2018.3.7
temp: generate vector oriAndFauCircuit
keeping: generate CNFFormula oriAndFauCNF
insert and delete fault in oriAndFauCNF

// 2018.3.8
// check the CNF formula correct or not?

// 2018.3.13
// ****** Find all redundant SSAF. But it's different from what sis found ????******
// check all AIG's input???? maybe incorrect??????
// need to propagate the input values and see what will happen
// ****start to do the verification******

// 2018.3.14
// ****first read the paper about the fault collapsing. First task in 2018.3.15
// should I consider the output's stuck-at 1? Since it cannot be replace by input's stuck at values
// meaning of fault ID should be changed->also include the gate outputs.!
// we should change it to that faults can be inserted to any place-->still some problem 2018.3.15

// another idea to verify the fault model:
// use the fault model to generate the test patterns for these faults.
// and again, check whether these test vectors can cover all faults.(all faults without collapsing)


// ************2018.3.30*****************
// 1. s444 fault 1101's test pattern can detect 1268, but the sat function said no.. The SAT function may have some problems(has checked in quartus)
// need to check the generation of sat(maybe we can compare it to sis. use some other small circuit to try).
// s382 has the same problem. fault 474 can be detected. however SAT-solver say not..
// ************already use sis check. s382 has no redundant faults. so the SAT function has problem. please check s382's CNF manully(check s27 first, then switch to big circuit) first************
// ************(SAT solver's part are quit important. we need to use it again and again later)************

**********************
case 1. my CNF generation has problems
  1. check the original+faulty Circuit's generation.
~~~~~~only check the corresponding gates~~~~~~about 20 gates....
******Find the problem!!!--->dont consider invOut when generate the CNF formula!!!!!*****

-------2018.4.11-------------
check fault 1252, is unsat, but the samefault_helper take it as non-redundant fault. find the reason.
***方法有问题

  2. If 1 has no problem, check the CNF has problem or not? compare with abc's CNF
case 2. glucose may has problem. can use s444 blif file to test. XXX. glucose has no problem. already proof it.
if glucose has no problem. then can print out its CNF formula and compare with my formula?
**********************


*******change the gate implementation such that it can support any number of input and any kinds of gate*********
***In and out's wire name of PI and PO are same, it should be changed****8



// 2. s1238 has same problem. But different. it's problem is the collapse function ...(both propagate fault and sat said, no. but it still select by our function.)
// our method is fast, but still need to check (findFaultsSameTest_helper??)

--------------------------------------------------------------
2018.4.19
Double fault detect parts
Map<testPattern, set<faults>>
1. check path
for each test pattern
    for each faults
        find its propagation path
        find the faults may block its propagation, redundant faults need to be considered
get the potentiallyUndetected set<faults, set of faults that will block it>
2. check the potentiallyUndetected set, find the undetected DSA.
3. check whether those DSAs can be detected by other patterns to compress
4. generate the final pattern use SAT(only use SAT here)

2018.4.20
when we check the test patterns, we dont need to propagate the fault
we can write another function to find the path.

TO DO:
check the function in S27.
(findBlockSSADFS, checkFaultAndTestVector, findUndetectedDSA, compressUndetectedDSA)
some faults do not need to be selected as block SSA....(previous slide)
use other pattern to check the undetectedDSA, and further decrease the size.
(*****may also need to check the checkFaultAndTestVector function for DSA faults*****)
at last not any SSA remaining.... many problems....

!!Have a idea to further reduce the running time.
When we propagate the input value, we dont need to traverse the entire circuit, we just find the gate connected with faulty gate,
and only propagate value in these gates..then it will be much faster.

A problem. only check the path from faulty gate to output.
for each block fault in the path, also need to look back and find the same faults.

2018.4.21
----sameFaultCurToPIDFS------
write a function to find the same fault(DFS recursive)
only stuckat 0 side value needs to do that.
1. if current gate is aig:
   choose the stuckat value in both input port, stuckat1 = (1-invIn1), stuckat2 = (1-invIn2);.
   if current gate is bufInv:
   outStuckat = 1 - outValue;
   stuckat = (outStuckat == invOut) == invIn1;
   check whether the faults are inside our fault model or not.
   put the fault into "blockFaultsList"
2. go to the fanin gate.
    go into fanin1,
    if it's aig, go to fanin2
base case
1. for AIG: if current gate stuck-at outValue == invOut, then return.
   (for bufInv just pass, cause it's stuckat value can definitely be propagated)
2. current gate is PI or constant, just return.
(after write this function, check in s27 again, check all faults' case).
---test case---
put bufinv, constant into circuit to see what will happen



2018.4.25
-----findConnectedGatesDFS, is ok, no problem----
----first find the PO then backtrace to PI----
find all gates that connected to the target gate
1. the path from that gate to PO
2. the side value in the path
3. the gate from that gate to PI
--1. in the main DFS function. 2,3 in another sub-DFS function.
--DFS main function gate->PO
input curGate, set.
go to all fan-out.
base case: PO, call the sub-function helper then return..
--DFS sub-function PO to PI.
input curGate, set
1. put current gate's index into set
2. go to all inputs(****bufInv only one input)
base case: PI or bufInv

2018.5.17
many function's result are different.
1. use CheckGivenPatterns to find potentially undetected
2. use checkFaultAndTestVector to find whether can be propagated?
3. use SAT to check
three has different results...
ok, first check 2. checkFaultAndTestVector.
When I use it to check single fault, many are undetected?but previouly many are detected????
what happens????

is the multiple faults works well?
Then we can check 1 and 3.


2018.5.31.
resetFaultsInCircuit has some problems
every time we dont pop all stuckat constants out.
because multiple faults may in same gate, we will add multiple constant in the cirucit,
but the time we pop out constants is equal to the gates number that are changed...
so I use other variable faultsInsertedCircuit to record the faults number for poping out operation.

*******review the code to generate CNF and the faultyCircuit.
**for S444. among the undetected faults by SSA test set, only four of them are detectable.
  check our function to find the undetected DSA....

bug1:没有把双Redundant的SSAF给考虑进去。
bug2：用map<int, int>来存可能DSA错误。不行的，这样子key一样的值会被覆盖掉。。。
bug3: 忽略了单边Redundant的 fault。。得找出原因。
      -->一开始还不知道哪些是redundant。。。。所以就找不出来了。

2018.6.7
ok.we solve the previous problem. for s444, I can find all undetected DSA (based on the fault model)
But the selected DSA number becomes large...
try to reduce them

2018.6.12
bug:
1. s444考虑所有fault的时候，会检测出一些我们的fault model检测不出来的错误。
   sol: 先单独看，不在我们的fault model里面的，有哪些redundant fault。
        之后检测blocking fault的时候，就可以把在fault model之外的redundant fault一起给考虑了。
   这样子我们可以得出所有的DSA fault。可以用于之后的TSA fault检测。
2. s9234及以上的大电路运行的时候segmentation fault....


2018.6.13
TODO
1. 将所有的recursion换成iterative方式
2. 其中一个还有一种情况没有往前考虑。写一个函数来检测。
