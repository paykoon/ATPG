------2017.11.30-------
Read the main.cc of glucose, need to understand the function in Dimacs.h
readClause(in, S, lits); //********
S.addClause_(lits); }    //********

------2017.12.15-------

need to know the way to use the library of glucose

----2017.12.17-----
template<class B, class Solver>
static void readClause(B& in, Solver& S, vec<Lit>& lits) {
    int     parsed_lit, var;
    lits.clear();
    for (;;){
        parsed_lit = parseInt(in);
        if (parsed_lit == 0) break;
        var = abs(parsed_lit)-1;
		//***********
    //print var's value , make sure the understanding..
        while (var >= S.nVars()) S.newVar();
        lits.push( (parsed_lit > 0) ? mkLit(var) : ~mkLit(var) );
    }
}

//----2017.12.18-------
the way to input the CNF formula
in readClause function
static void readClause(B& in, Solver& S, vec<Lit>& lits) {
    int     parsed_lit, var;
    lits.clear();
    for (;;){
		//*****usage: send all literal to parsed_lit one by one, send "0" at last******
        parsed_lit = parseInt(in);
        if (parsed_lit == 0) break; // the end of line has "0". when meet it, break.
        var = abs(parsed_lit)-1;
		//*****
        while (var >= S.nVars()) S.newVar();
        lits.push( (parsed_lit > 0) ? mkLit(var) : ~mkLit(var) );
    }
}

in main functions. we can write the answer
//********************************************
if (ret == l_True){
  printf("***************SAT Solutin**************\n");
  for (int i = 0; i < S.nVars(); i++) {
    if (S.model[i] != l_Undef) {
      int out = (S.model[i]==l_True)? 1 : 0;
      printf("%d ",out);
    }
  }
  printf("\n");
}
else if (ret == l_False){
    printf("***************UNSAT***************\n");
}
//********************************************



*****TODO******still undone
//2018.1.27
TO DO:
verify the result of glucose in S27
link to circuit by XOR, and put it into SAT-solver
write the program for SIS

// 2018.1.30
TO DO:
link the output with XOR(circuit.h --> function oriXORFaulty)

// 2018.3.7
temp: generate vector oriAndFauCircuit
keeping: generate CNFFormula oriAndFauCNF
insert and delete fault in oriAndFauCNF

// 2018.3.8
// check the CNF formula correct or not?

// 2018.3.13
// ****** Find all redundant SSAF. But it's different from what sis found ????******
// check all AIG's input???? maybe incorrect??????
// need to propagate the input values and see what will happen
// ****start to do the verification******

// 2018.3.14
// ****first read the paper about the fault collapsing. First task in 2018.3.15
// should I consider the output's stuck-at 1? Since it cannot be replace by input's stuck at values
// meaning of fault ID should be changed->also include the gate outputs.!
// we should change it to that faults can be inserted to any place-->still some problem 2018.3.15

// another idea to verify the fault model:
// use the fault model to generate the test patterns for these faults. 
// and again, check whether these test vectors can cover all faults.(all faults without collapsing)
